\documentclass{article}
\usepackage{listings}
\usepackage{times}
\usepackage{amssymb, amsmath, amsthm}
\usepackage[margin=.5in]{geometry}
\usepackage{graphicx}
\usepackage[linewidth=1pt]{mdframed}

\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}
\usepackage{transparent}

\newcommand{\incfig}[1]{%
    \def\svgwidth{.5\linewidth}
    \import{./figures/}{#1.pdf_tex}
}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem*{remark}{Remark}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\begin{document}

\title{Analysis of Algorithms - Notes}
\author{Philip Warton}
\date{\today}
\maketitle
\section{Graph Search Algorithms}
We begin with this simple example of the ``whatever first search''. This is an algorithm that will brute force find some
path from $v \rightarrow s$ for any $s$-reachble vertex $v$.
\begin{mdframed}
    Whatever-first-search algorithm with path rememberance:
    \begin{lstlisting}[mathescape=true]
WFS(G,s) {
    Parent(s) = $\O$
    Bag = $\{(s, \O)\}$
    while Bag $\neq \O$ {
        $(v,p)$ = any vertex from Bag
            (remove $v$ from Bag)
        if $v$ is not marked {
            mark $v$
            Parent(v) = p
            for all $(v,w) \in E$ {
              `'  add $(w,v)$ to Bag
            }
        }
    }
}
    \end{lstlisting}
\end{mdframed}
\begin{figure}[ht]
    \centering
    \incfig{wfs}
    \caption{Whatever First Search For $v_8 \rightarrow s$}
    \label{fig:wfs}
\end{figure}
Once the bag is eventually empty, we can find the path from 
$v$ to $s$ by
\[
    v \rightarrow \text{parent}(v) \rightarrow \text{parent}(\text{parent}(v)) \rightarrow \cdots \rightarrow s
\]
The WFS algorithm marks all vertices reachable from $s$.
\begin{proof}
    Let $s$ be our initial point. We use induction that is based on the shortest path $s$ to $v$. \\\\
    \fbox{Base Case:} Our vertex $v = s$, and ShortestPathLength$(v\rightarrow s) = 0$, and WFS marks it on the first iteration.\\\\
    \fbox{Inductive Step:} For any point $v$ for which the shortest path $s \leftarrow v$ is smaller than $k \in \mathbb{N}$,
    we assume that WFS has already marked $v$. Let $v$ be a point for which its minimum distance from $s$ is $k$.
    Then let $u$ be the neighbor of $v$ that lies on 
    a shortest path from $v$ to $s$. Then the length of $u \rightarrow s$ is $k-1$, and by assumption $u$ is marked.
    Since $v$ is a neighbor of $u$, $v$ will be marked as well.
\end{proof}
What kind of data structures would be good to use for Bag? If 
we use a stack, then this algorithm becomes a depth first search algorithm (DFS).
If we use a queue, then we have a breadth first search (BFS) algorithm.
If there is a weighted graph, one can use a priority queue based on edge weight,
resulting in Dijkstra's shortest path algorithm.
\begin{lstlisting}[mathescape=true]
Serach(G,s):
    Insert $s$ into Bag
    while Bag $\neq \O$:
        $v$: any vertex from Bag
        if $v$ is not marked:
            mark $v$
            $\forall v \rightarrow w \in E$
                insert $w$ into Bag
\end{lstlisting}
If we use a stack, we have DFS, if we use queue we have BFS, if we have priority queue/heap, we have
either Dijkstra's or Prim's algorithm.
\subsection*{Dijkstra's Algorithm}
This algorithm utilizes a priority queue in order to find the shortest path from $s$
to any vertex $v$.
\begin{lstlisting}[mathescape=true]
Dijkstra(G,s):
    priQ = $\{(s,0)\}$
    while priQ $\neq \O$:
        $(v,d) \leftarrow$ priQ.ExtractMin
        if $v$ is not marked:
            mark $v$
            $\forall v \rightarrow w \in E$:
                priQ.Insert$(w, d + l(v \rightarrow w))$
\end{lstlisting}
The shortes path problem takes some directed graph $G = (V,E)$ where we have a length function $l: E \rightarrow \mathbb{R}^+$,
$s \in V$. Then we output the shortest path from $s$ to $v$ for every vertex $v \in V$.
\begin{figure}[ht]
    \centering
    \incfig{dijkstras}
    \caption{Dijkstra's Algorithm on $G = (V,E)$}
    \label{fig:dijkstras}
\end{figure}
The running time of this algorithm is $O(E \log V)$ since our priority queue insert function runs in $O(\log V)$ time.
A graph with negative weights does not work, especially so if it is cyclic, because the shortest Dijkstra path may not be 
the shortest actual path, and if it is cyclic, there may not even exist a shortest path.
\begin{figure}[ht]
    \centering
    \incfig{negativecycle}
    \caption{A Negative Cyclic Graph}
    \label{fig:negativecycle}
\end{figure}

\section{Minimum Spanning Tees}

\section{Greedy Algorithms}
    Our first example is a job scheduling algorithm. Each shift has a start time and an end time.
    The inputs for this algorithm are a list of start and end times, $S[1,2,\cdots,n], F[1,2,\cdots,n]$.
    The output will be the maximum number of disjoint shifts. The greedy algorithm solution, involves taking
    the largest start time, and go from there.
    \begin{mdframed}
        Greedy Algorithm to Solve the Job Scheduling Problem
        \begin{lstlisting}[mathescape=true]
JobScheduling$(S,F)$
    Sort $F$, Permute $S$ accordingly
    endTime $= -\infty$
    todoList = {}
    for $i \leftarrow 1$ to n
        if $S[i] >$ endTime
            Add $i$ to todoList
            endtime = $F[i]$
    return todoList
        \end{lstlisting}
    \end{mdframed}
    \begin{figure}[ht]
        \centering
        \incfig{jobsched}
        \caption{Job Scheduling Algorithm : Smallest Endpoint}
        \label{fig:jobsched}
    \end{figure}
    The above algorithm does in fact return the maximum number of possible disjoint shifts.
    \begin{proof}
        Denote $g_1,g_2,\cdots,g_t$ as the output of our greedy algorithm, and denote $opt_1,opt_2,\cdots,opt_k$
        to be the optimal solution with max shared prefix to our soluion.
        If $k \leqslant t$, then clearly $g$ is optimal. Otherwise, $k > t$.
        Suppose that there exists $i \in 1,2,\cdots t$ such that $g_i \neq opt_i$. Choose the first such $i$.
        Then for $n < i, g_i \cap g_n = \O$. Then $F[g_i] \leqslant F[opt_i]$, and since $opt_i$ is disjoint from
        all $opt_{i+1},\cdots,opt_n$, it follows that  $g_i$ is disjoint with $opt_{i+1},\cdots,opt_n$.
        Then $opt_1,\cdots, opt_{i-1},g_i,opt_{i+1},\cdots,opt_k$ is a valid scheduling and is optimal.
        Thus there exists some optimal solution with a prefix more similar to $g$ than $opt$ is, contradicting our 
        definition of $opt$.
    \end{proof}
    Our next example will be the Huffman Coding problem. We want to make our file as small as possible. We must make 
    the encoding prefix free, or if we think of it as a binary tree, every encoding must be a leaf node.
    Our input is the fequency of symbols, our output is the best possible prefix free code.\\\\
    To do this, we can merge the two least frequent items $(x,f[x]),(y,f[y]) \rightarrow(`xy', f[x] + f[y])$. Then we
    compute the optimal tree with $n-1$ symbols. Then we add the childred $x,y$ to the leaf `$xy$'.
    
\end{document}